<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL í…Œì´ë¸” ì¶”ì¶œê¸° v07</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
       
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .input-section {
            margin-bottom: 30px;
        }
        
        .input-section label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }
        
        textarea {
            width: 100%;
            min-height: 300px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .result-section {
            margin-top: 30px;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .result-header h2 {
            color: #333;
            font-size: 22px;
        }
        
        .stats {
            display: flex;
            gap: 20px;
        }
        
        .stat-item {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
        }
        
        .stat-item .number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-item .label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 5px;
            overflow: hidden;
        }
        
        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        th {
            padding: 15px;
            text-align: left;
            font-weight: bold;
            font-size: 14px;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 14px;
        }
        
        tbody tr:hover {
            background: #f8f9fa;
        }
        
        tbody tr:last-child td {
            border-bottom: none;
        }
        
        .type-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .type-select {
            background: #667eea;
            color: white;
        }
        
        .type-insert {
            background: #28a745;
            color: white;
        }
        
        .type-update {
            background: #ffc107;
            color: #333;
        }
        
        .type-delete {
            background: #dc3545;
            color: white;
        }
        
        .type-merge {
            background: #17a2b8;
            color: white;
        }
        
        .type-exec {
            background: #6f42c1;
            color: white;
        }
        
        .no-results {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 16px;
        }
        
        .table-name {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #333;
        }
        
        .filter-section {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .filter-section select {
            padding: 8px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .filter-section select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .filter-section {
            justify-content: space-between;
        }
        
        table th input[type="checkbox"] {
            margin-left: 5px;
            cursor: pointer;
        }
        
        .file-item {
            padding: 5px 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 3px;
            display: inline-block;
            margin-right: 10px;
        }
        
        @keyframes progress {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }
        
        .progress-fill {
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: progress 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” SQL í…Œì´ë¸” ì¶”ì¶œê¸°</h1>
            <p>í”„ë¡œì‹œì € ë˜ëŠ” ì¿¼ë¦¬ë¬¸ì„ ì…ë ¥í•˜ë©´ íƒ€ì…ë³„ í…Œì´ë¸”ì„ ìë™ìœ¼ë¡œ ì¶”ì¶œí•©ë‹ˆë‹¤</p>
        </div>
        
        <div class="content">
            <div class="input-section">
                <label for="fileInput">SQL íŒŒì¼ ì—…ë¡œë“œ (ì—¬ëŸ¬ íŒŒì¼ ì„ íƒ ê°€ëŠ¥):</label>
                <input type="file" id="fileInput" multiple accept=".sql,.xsql,.txt" style="width: 100%; padding: 10px; margin-bottom: 15px; border: 2px solid #e0e0e0; border-radius: 5px; font-size: 14px; cursor: pointer;">
                <div id="fileList" style="margin-bottom: 15px; font-size: 14px; color: #666;"></div>
                
                <label for="sqlInput" style="margin-top: 20px;">ë˜ëŠ” SQL í”„ë¡œì‹œì € ë˜ëŠ” ì¿¼ë¦¬ë¬¸ ì§ì ‘ ì…ë ¥:</label>
                <textarea id="sqlInput" placeholder="CREATE PROCEDURE ... ë˜ëŠ” SELECT ... FROM ... ë“±ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
                <div class="button-group">
                    <button class="btn-primary" onclick="extractTables()">í…Œì´ë¸” ì¶”ì¶œ</button>
                    <button class="btn-secondary" onclick="clearAll()">ì „ì²´ ì§€ìš°ê¸°</button>
                </div>
            </div>
            
            <div class="result-section" id="resultSection" style="display: none;">
                <div class="result-header">
                    <h2>ì¶”ì¶œ ê²°ê³¼</h2>
                    <div class="stats" id="stats"></div>
                </div>
                
                <div class="filter-section">
                    <label>íƒ€ì… í•„í„°:</label>
                    <select id="typeFilter" onchange="filterTable()">
                        <option value="all">ì „ì²´</option>
                        <option value="select">SELECT</option>
                        <option value="insert">INSERT</option>
                        <option value="update">UPDATE</option>
                        <option value="delete">DELETE</option>
                        <option value="merge">MERGE</option>
                        <option value="exec">PROCEDURE</option>
                    </select>
                    <button class="btn-primary" onclick="copySelectedColumns()" style="margin-left: auto;">Copy</button>
                </div>
                
                <div id="tableContainer"></div>
            </div>
        </div>
    </div>

    <script>
        var allTables = [];
        var filteredTables = [];
        var cteNames = [];
        var uploadedFiles = [];
        var MAX_FROM_CLAUSE_LENGTH = 4000;

        // íŒŒì¼ ì„ íƒ ì´ë²¤íŠ¸
        document.addEventListener('DOMContentLoaded', function() {
            var fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    uploadedFiles = Array.from(e.target.files);
                    displayFileList();
                });
            }
        });

        function displayFileList() {
            var fileListDiv = document.getElementById('fileList');
            if (uploadedFiles.length === 0) {
                fileListDiv.innerHTML = '';
                return;
            }
            
            var html = '<strong>ì„ íƒëœ íŒŒì¼ (' + uploadedFiles.length + 'ê°œ):</strong><br>';
            for (var i = 0; i < uploadedFiles.length; i++) {
                html += '<span class="file-item">' + escapeHtml(uploadedFiles[i].name) + '</span>';
            }
            fileListDiv.innerHTML = html;
        }

        function extractTables() {
            // íŒŒì¼ì´ ì„ íƒë˜ì—ˆëŠ”ì§€ í™•ì¸
            var fileInput = document.getElementById('fileInput');
            var sqlInput = document.getElementById('sqlInput');
            
            if (uploadedFiles.length === 0 && !sqlInput.value.trim()) {
                alert('SQL íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ SQL ë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            allTables = [];
            cteNames = [];
            
            // ì§„í–‰ ìƒíƒœ í‘œì‹œ
            showProgress('ì²˜ë¦¬ ì¤‘...');
            
            // íŒŒì¼ì´ ìˆìœ¼ë©´ íŒŒì¼ë¶€í„° ì²˜ë¦¬
            if (uploadedFiles.length > 0) {
                processFiles(0);
            } else {
                // íŒŒì¼ì´ ì—†ìœ¼ë©´ í…ìŠ¤íŠ¸ ì…ë ¥ ì²˜ë¦¬ (ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬)
                var sqlText = sqlInput.value.trim();
                processSQLTextAsync(sqlText, 'ì§ì ‘ ì…ë ¥', function() {
                    hideProgress();
                    removeDuplicates();
                    displayResults();
                });
            }
        }
        
        function preprocessSQLText(sqlText) {
            if (!sqlText) return '';
            var text = sqlText;
            text = text.replace(/<!\[CDATA\s*\[/gi, '');
            text = text.replace(/\]\]>/g, '');
            text = text.replace(/<!--[\s\S]*?-->/g, ' ');
            text = text.replace(/\/\*[\s\S]*?\*\//g, ' ');
            text = text.replace(/--[^\n\r]*/g, '');
            return text;
        }
        
        function showProgress(message) {
            var resultSection = document.getElementById('resultSection');
            resultSection.style.display = 'block';
            var container = document.getElementById('tableContainer');
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: #667eea; font-size: 16px;">' + 
                '<div style="margin-bottom: 10px;">' + message + '</div>' +
                '<div class="progress-bar" style="width: 100%; height: 4px; background: #e0e0e0; border-radius: 2px; overflow: hidden;">' +
                '<div class="progress-fill" style="width: 0%; height: 100%; background: #667eea; transition: width 0.3s; animation: progress 2s infinite;"></div>' +
                '</div>' +
                '</div>';
        }
        
        function hideProgress() {
            // ì§„í–‰ ìƒíƒœ ìˆ¨ê¸°ê¸°
        }
        
        function processSQLTextAsync(sqlText, fileName, callback) {
            // í° íŒŒì¼ì˜ ê²½ìš° ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬
            if (sqlText.length > 50000) {
                processSQLTextInChunks(sqlText, fileName, callback);
            } else {
                processSQLText(sqlText, fileName);
                if (callback) callback();
            }
        }
        
        function processSQLTextInChunks(sqlText, fileName, callback) {
            var chunkSize = 50000;
            var currentPos = 0;
            var fileCTENames = [];
            var cleanedText = preprocessSQLText(sqlText);
            var sqlUpper = cleanedText.toUpperCase();
            var totalLength = cleanedText.length;
            
            // ë¨¼ì € CTE ì´ë¦„ ì „ì²´ ì¶”ì¶œ
            extractCTENames(cleanedText, sqlUpper, fileCTENames);
            
            function processChunk() {
                var endPos = Math.min(currentPos + chunkSize, cleanedText.length);
                var chunk = cleanedText.substring(currentPos, endPos);
                var chunkUpper = chunk.toUpperCase();
                
                // ì²­í¬ ì²˜ë¦¬
                extractSelectTables(chunk, chunkUpper, fileName, fileCTENames);
                extractInsertTables(chunk, chunkUpper, fileName, fileCTENames);
                extractUpdateTables(chunk, chunkUpper, fileName, fileCTENames);
                extractDeleteTables(chunk, chunkUpper, fileName, fileCTENames);
                extractMergeTables(chunk, chunkUpper, fileName, fileCTENames);
                extractProcedureCalls(chunk, chunkUpper, fileName, fileCTENames);
                
                currentPos = endPos;
                
                // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
                var progress = totalLength === 0 ? 100 : Math.min(100, Math.round((currentPos / totalLength) * 100));
                var progressFill = document.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = progress + '%';
                }
                
                if (currentPos < cleanedText.length) {
                    // ë‹¤ìŒ ì²­í¬ ì²˜ë¦¬ (ë¹„ë™ê¸°)
                    setTimeout(processChunk, 10);
                } else {
                    // ì™„ë£Œ
                    if (callback) callback();
                }
            }
            
            processChunk();
        }
        
        function processFiles(index) {
            if (index >= uploadedFiles.length) {
                // ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ
                hideProgress();
                removeDuplicates();
                displayResults();
                return;
            }
            
            var file = uploadedFiles[index];
            var fileName = file.name;
            var reader = new FileReader();
            
            reader.onload = function(e) {
                var sqlText = e.target.result;
                
                // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
                var progress = Math.round(((index + 1) / uploadedFiles.length) * 100);
                var progressFill = document.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = progress + '%';
                }
                
                if (sqlText.length > 50000) {
                    // í° íŒŒì¼ì€ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬
                    processSQLTextInChunks(sqlText, fileName, function() {
                        // ë‹¤ìŒ íŒŒì¼ ì²˜ë¦¬
                        setTimeout(function() {
                            processFiles(index + 1);
                        }, 10);
                    });
                } else {
                    processSQLText(sqlText, fileName);
                    // ë‹¤ìŒ íŒŒì¼ ì²˜ë¦¬
                    setTimeout(function() {
                        processFiles(index + 1);
                    }, 10);
                }
            };
            
            reader.onerror = function() {
                alert('íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: ' + fileName);
                processFiles(index + 1);
            };
            
            reader.readAsText(file);
        }
        
        function processSQLText(sqlText, fileName) {
            if (!sqlText || !sqlText.trim()) {
                return;
            }
            
            var cleanedText = preprocessSQLText(sqlText);
            if (!cleanedText.trim()) {
                return;
            }
            
            // SQLì„ ëŒ€ë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ íŒŒì‹± (ì›ë³¸ì€ ìœ ì§€)
            var sqlUpper = cleanedText.toUpperCase();
            
            // CTE ì´ë¦„ ì¶”ì¶œ (ì œì™¸ ëª©ë¡) - íŒŒì¼ë³„ë¡œ ë…ë¦½ì ìœ¼ë¡œ ì²˜ë¦¬
            var fileCTENames = [];
            extractCTENames(cleanedText, sqlUpper, fileCTENames);
            
            // SELECT ë¬¸ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
            extractSelectTables(cleanedText, sqlUpper, fileName, fileCTENames);
            extractExpressionSubqueryTables(cleanedText, fileName, fileCTENames);
            
            // INSERT ë¬¸ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
            extractInsertTables(cleanedText, sqlUpper, fileName, fileCTENames);
            
            // UPDATE ë¬¸ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
            extractUpdateTables(cleanedText, sqlUpper, fileName, fileCTENames);
            
            // DELETE ë¬¸ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
            extractDeleteTables(cleanedText, sqlUpper, fileName, fileCTENames);
            
            // MERGE ë¬¸ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
            extractMergeTables(cleanedText, sqlUpper, fileName, fileCTENames);
            
            // EXEC/EXECUTE ë¬¸ì—ì„œ í”„ë¡œì‹œì € ì¶”ì¶œ
            extractProcedureCalls(cleanedText, sqlUpper, fileName, fileCTENames);
        }
        
        function extractCTENames(sqlText, sqlUpper, cteNamesArray) {
            // WITH ì ˆì—ì„œ CTE ì´ë¦„ ì¶”ì¶œ
            var withPattern = /WITH\s+([A-Za-z_][A-Za-z0-9_]*)\s+AS/gi;
            var match;
            
            while ((match = withPattern.exec(sqlText)) !== null) {
                var cteName = match[1].trim();
                if (cteName) {
                    cteNamesArray.push(cteName.toUpperCase());
                }
            }
            
            // ì—¬ëŸ¬ CTEê°€ ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ê²½ìš°
            var multiCTEPattern = /,\s*([A-Za-z_][A-Za-z0-9_]*)\s+AS/gi;
            while ((match = multiCTEPattern.exec(sqlText)) !== null) {
                var cteName = match[1].trim();
                if (cteName) {
                    cteNamesArray.push(cteName.toUpperCase());
                }
            }
        }

        function stripNestedParenthesesContent(text) {
            if (!text) return '';
            var result = '';
            var depth = 0;
            var inSingle = false;
            var inDouble = false;
            for (var i = 0; i < text.length; i++) {
                var ch = text[i];
                var nextChar = i + 1 < text.length ? text[i + 1] : '';
                if (!inDouble && ch === "'") {
                    if (inSingle && nextChar === "'") {
                        // Escaped single quote inside string
                        result += depth === 0 ? ch : ' ';
                        i++;
                        result += depth === 0 ? text[i] : ' ';
                        continue;
                    }
                    inSingle = !inSingle;
                    result += depth === 0 ? ch : ' ';
                    continue;
                }
                if (!inSingle && ch === '"') {
                    inDouble = !inDouble;
                    result += depth === 0 ? ch : ' ';
                    continue;
                }
                if (inSingle || inDouble) {
                    result += depth === 0 ? ch : ' ';
                    continue;
                }
                if (ch === '(') {
                    depth++;
                    result += ' ';
                    continue;
                }
                if (ch === ')') {
                    if (depth > 0) {
                        depth--;
                    }
                    result += ' ';
                    continue;
                }
                if (depth === 0) {
                    result += ch;
                } else {
                    result += ' ';
                }
            }
            return result;
        }
        
        function unwrapOuterParentheses(text) {
            if (!text) return '';
            var trimmed = text.trim();
            while (trimmed.startsWith('(')) {
                var result = extractBalancedParenthesesContent(trimmed, 0);
                if (result && result.endIndex === trimmed.length - 1) {
                    trimmed = result.content.trim();
                } else {
                    break;
                }
            }
            return trimmed;
        }

        function extractBalancedParenthesesContent(text, startIndex) {
            if (!text || startIndex < 0 || startIndex >= text.length || text[startIndex] !== '(') {
                return null;
            }
            var depth = 0;
            var inSingle = false;
            var inDouble = false;
            for (var i = startIndex; i < text.length; i++) {
                var ch = text[i];
                var nextChar = i + 1 < text.length ? text[i + 1] : '';
                if (!inDouble && ch === "'") {
                    if (inSingle && nextChar === "'") {
                        i++;
                        continue;
                    }
                    inSingle = !inSingle;
                    continue;
                }
                if (!inSingle && ch === '"') {
                    inDouble = !inDouble;
                    continue;
                }
                if (inSingle || inDouble) {
                    continue;
                }
                if (ch === '(') {
                    depth++;
                    continue;
                }
                if (ch === ')') {
                    depth--;
                    if (depth === 0) {
                        return {
                            content: text.substring(startIndex + 1, i),
                            endIndex: i
                        };
                    }
                }
            }
            return null;
        }

        function findClauseBoundaryIndex(textUpper) {
            if (!textUpper) return -1;
            var boundaryRegex = /\b(WHERE|GROUP|ORDER|HAVING|UNION|INTERSECT|EXCEPT|LIMIT|OFFSET|INNER\s+JOIN|LEFT\s+JOIN|RIGHT\s+JOIN|FULL\s+JOIN|CROSS\s+JOIN|JOIN|SELECT|WITH|INSERT|UPDATE|DELETE|MERGE|EXEC|EXECUTE|CALL)\b/;
            var boundaryMatch = boundaryRegex.exec(textUpper);
            var boundaryIndex = boundaryMatch ? boundaryMatch.index : -1;
            var semicolonIndex = textUpper.indexOf(';');
            if (semicolonIndex !== -1 && (boundaryIndex === -1 || semicolonIndex < boundaryIndex)) {
                boundaryIndex = semicolonIndex;
            }
            return boundaryIndex;
        }
        
        function extractSelectTables(sqlText, sqlUpper, fileName, fileCTENames) {
            // FROM ì ˆ ì „ì²´ë¥¼ ì°¾ì•„ì„œ ì²˜ë¦¬
            var fromPattern = /FROM\s+/gi;
            var match;
            var matches = [];
            
            // ëª¨ë“  FROM ìœ„ì¹˜ë¥¼ ë¨¼ì € ìˆ˜ì§‘ (ì •ê·œì‹ execëŠ” ìƒíƒœë¥¼ ìœ ì§€í•˜ë¯€ë¡œ)
            while ((match = fromPattern.exec(sqlText)) !== null) {
                matches.push(match.index);
            }
            
            // ê° FROM ì ˆ ì²˜ë¦¬
            for (var i = 0; i < matches.length; i++) {
                var fromStart = matches[i] + 4; // "FROM" ê¸¸ì´
                var sliceEnd = Math.min(sqlText.length, fromStart + MAX_FROM_CLAUSE_LENGTH);
                var clauseSlice = sqlText.substring(fromStart, sliceEnd);
                var clauseSliceUpper = sqlUpper.substring(fromStart, sliceEnd);
                var strippedSliceUpper = stripNestedParenthesesContent(clauseSliceUpper);
                var boundaryIndex = findClauseBoundaryIndex(strippedSliceUpper);
                var fromEnd = boundaryIndex !== -1 ? fromStart + boundaryIndex : sliceEnd;
                var fromClause = sqlText.substring(fromStart, fromEnd);
                if (!fromClause.trim()) {
                    continue;
                }
                var clauseForPattern = stripNestedParenthesesContent(fromClause);
                
                // FROM ì ˆì—ì„œ í…Œì´ë¸” ì¶”ì¶œ (ìµœì í™”: ì •ê·œì‹ìœ¼ë¡œ í•œ ë²ˆì— ì°¾ê¸°)
                // í…Œì´ë¸”ëª… íŒ¨í„´: schema.table alias ë˜ëŠ” table alias
                var tablePattern = /(?:^|\s|,)\s*((?:\[?[A-Za-z_][A-Za-z0-9_]*\]?\.)?\[?#?[A-Za-z_][A-Za-z0-9_]*\]?)\s+([A-Za-z_][A-Za-z0-9_]*)/gi;
                var tableMatch;
                
                while ((tableMatch = tablePattern.exec(clauseForPattern)) !== null) {
                    var fullTableRef = tableMatch[1].trim();
                    if (!fullTableRef) continue;
                    
                    // ì„œë¸Œì¿¼ë¦¬ ì²´í¬ (ê´„í˜¸ë¡œ ì‹œì‘í•˜ëŠ”ì§€)
                    var matchStart = tableMatch.index;
                    var beforeMatch = fromClause.substring(Math.max(0, matchStart - 10), matchStart);
                    if (/\(/i.test(beforeMatch)) {
                        // ê´„í˜¸ê°€ ìˆìœ¼ë©´ ì„œë¸Œì¿¼ë¦¬ì¼ ê°€ëŠ¥ì„± - ê±´ë„ˆë›°ê¸°
                        continue;
                    }
                    
                    var tableName = extractTableNameFromRef(fullTableRef);
                    if (tableName && !isKeyword(tableName) && !isCTENameInFile(tableName, fileCTENames)) {
                        allTables.push({
                            type: 'select',
                            name: tableName,
                            fileName: fileName
                        });
                    }
                }
                
                processSubqueriesInFromClause(fromClause, fileName, fileCTENames);
            }
            
            // JOIN íŒ¨í„´ ì°¾ê¸° (CTE ì œì™¸, ìŠ¤í‚¤ë§ˆëª… í¬í•¨ ì§€ì›) - ìµœì í™”: ëª¨ë“  ë§¤ì¹˜ë¥¼ ë¨¼ì € ìˆ˜ì§‘
            var joinPattern = /(?:INNER|LEFT|RIGHT|FULL|OUTER)?\s*JOIN\s+((?:\[?[A-Za-z_][A-Za-z0-9_]*\]?\.)?\[?#?[A-Za-z_][A-Za-z0-9_]*\]?)/gi;
            var joinMatches = [];
            var tempMatch;
            while ((tempMatch = joinPattern.exec(sqlText)) !== null) {
                joinMatches.push(tempMatch[1]);
            }
            
            // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ Set ì‚¬ìš©
            var seenJoinTables = {};
            for (var j = 0; j < joinMatches.length; j++) {
                var joinFullRef = joinMatches[j].trim();
                var tableName = extractTableNameFromRef(joinFullRef);
                if (tableName && !isKeyword(tableName) && !isCTENameInFile(tableName, fileCTENames)) {
                    var key = 'select|' + tableName.toUpperCase() + '|' + fileName;
                    if (!seenJoinTables[key]) {
                        seenJoinTables[key] = true;
                        allTables.push({
                            type: 'select',
                            name: tableName,
                            fileName: fileName
                        });
                    }
                }
            }
        }
        
        // ì„œë¸Œì¿¼ë¦¬ ë‚´ë¶€ì˜ FROM ì ˆì—ì„œ í…Œì´ë¸” ì¶”ì¶œí•˜ëŠ” í—¬í¼ í•¨ìˆ˜ (ìµœì í™”ë¨)
        function extractTablesFromSubquery(subqueryText, fileName, fileCTENames) {
            // ì„œë¸Œì¿¼ë¦¬ ë‚´ë¶€ì˜ FROM ì ˆ ì°¾ê¸° - ìµœì í™”: ëª¨ë“  ë§¤ì¹˜ë¥¼ ë¨¼ì € ìˆ˜ì§‘
            var fromPattern = /FROM\s+((?:\[?[A-Za-z_][A-Za-z0-9_]*\]?\.)?\[?#?[A-Za-z_][A-Za-z0-9_]*\]?)/gi;
            var matches = [];
            var match;
            while ((match = fromPattern.exec(subqueryText)) !== null) {
                matches.push(match[1]);
            }
            
            // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ Set ì‚¬ìš©
            var seen = {};
            for (var i = 0; i < matches.length; i++) {
                var fullTableRef = matches[i].trim();
                var tableName = extractTableNameFromRef(fullTableRef);
                
                if (tableName && !isKeyword(tableName) && !isCTENameInFile(tableName, fileCTENames)) {
                    var key = 'select|' + tableName.toUpperCase() + '|' + fileName;
                    if (!seen[key]) {
                        seen[key] = true;
                        allTables.push({
                            type: 'select',
                            name: tableName,
                            fileName: fileName
                        });
                    }
                }
            }
        }
        
        function extractExpressionSubqueryTables(sqlText, fileName, fileCTENames) {
            if (!sqlText) return;
            var patterns = [
                /\b(?:NOT\s+)?IN\s*\(/gi,
                /\bEXISTS\s*\(/gi
            ];
            
            for (var p = 0; p < patterns.length; p++) {
                var regex = patterns[p];
                var match;
                while ((match = regex.exec(sqlText)) !== null) {
                    var openIndex = match.index;
                    while (openIndex < sqlText.length && sqlText[openIndex] !== '(') {
                        openIndex++;
                    }
                    if (openIndex >= sqlText.length) {
                        break;
                    }
                    
                    var result = extractBalancedParenthesesContent(sqlText, openIndex);
                    if (!result || !result.content) {
                        break;
                    }
                    
                    var subqueryContent = unwrapOuterParentheses(result.content);
                    if (/^\s*SELECT\b/i.test(subqueryContent)) {
                        extractTablesFromSubquery(subqueryContent, fileName, fileCTENames);
                    }
                    
                    regex.lastIndex = result.endIndex + 1;
                }
            }
        }
        
        function processSubqueriesInFromClause(fromClause, fileName, fileCTENames) {
            if (!fromClause) return;
            var pattern = /\(\s*SELECT/gi;
            var match;
            while ((match = pattern.exec(fromClause)) !== null) {
                var openIndex = match.index;
                // ensure the character at openIndex is '('
                while (openIndex < fromClause.length && fromClause[openIndex] !== '(') {
                    openIndex++;
                }
                if (openIndex >= fromClause.length) {
                    break;
                }
                var result = extractBalancedParenthesesContent(fromClause, openIndex);
                if (result && result.content) {
                    extractTablesFromSubquery(result.content, fileName, fileCTENames);
                    pattern.lastIndex = openIndex + result.content.length + 2;
                } else {
                    break;
                }
            }
        }
        
        // ìŠ¤í‚¤ë§ˆëª… í¬í•¨ í…Œì´ë¸” ì°¸ì¡°ì—ì„œ í…Œì´ë¸”ëª…ë§Œ ì¶”ì¶œí•˜ëŠ” í—¬í¼ í•¨ìˆ˜
        // schema.table -> table
        // [schema].[table] -> table
        // table -> table
        function extractTableNameFromRef(fullRef) {
            if (!fullRef) return '';
            
            // ëŒ€ê´„í˜¸ ì œê±°
            fullRef = fullRef.replace(/[\[\]]/g, '');
            
            // ì (.)ìœ¼ë¡œ êµ¬ë¶„í•˜ì—¬ ë§ˆì§€ë§‰ ë¶€ë¶„ì´ í…Œì´ë¸”ëª…
            var parts = fullRef.split('.');
            if (parts.length > 1) {
                // ìŠ¤í‚¤ë§ˆëª….table í˜•ì‹
                return parts[parts.length - 1].trim();
            } else {
                // table í˜•ì‹
                return parts[0].trim();
            }
        }
        
        function extractInsertTables(sqlText, sqlUpper, fileName, fileCTENames) {
            // INSERT INTO í…Œì´ë¸”ëª… íŒ¨í„´
            var insertPattern = /INSERT\s+(?:INTO\s+)?([#]?[A-Za-z_][A-Za-z0-9_]*)/gi;
            var match;
            
            while ((match = insertPattern.exec(sqlText)) !== null) {
                var tableName = match[1].trim();
                if (tableName && !isKeyword(tableName)) {
                    allTables.push({
                        type: 'insert',
                        name: tableName,
                        fileName: fileName
                    });
                }
            }
        }
        
        function extractUpdateTables(sqlText, sqlUpper, fileName, fileCTENames) {
            // UPDATE ë¬¸ì„ ì°¾ì•„ì„œ ë¸”ë¡ ë‹¨ìœ„ë¡œ ì²˜ë¦¬
            // MERGE ë¬¸ ë‚´ë¶€ì˜ "update set"ì€ ì œì™¸ (WHEN MATCHED THEN UPDATE SET)
            var updateRegex = /UPDATE\s+([#]?[A-Za-z_][A-Za-z0-9_]*)\s+SET/gi;
            var updateMatch;
            
            while ((updateMatch = updateRegex.exec(sqlText)) !== null) {
                var updateStart = updateMatch.index;
                var alias = updateMatch[1].trim();
                
                // MERGE ë¬¸ ë‚´ë¶€ì˜ UPDATEì¸ì§€ í™•ì¸
                // UPDATE ì•ì— "THEN"ì´ ìˆìœ¼ë©´ MERGE ë¬¸ ë‚´ë¶€ì˜ UPDATE
                var beforeUpdate = sqlText.substring(Math.max(0, updateStart - 50), updateStart).toUpperCase();
                if (beforeUpdate.indexOf('THEN') !== -1) {
                    // MERGE ë¬¸ ë‚´ë¶€ì˜ UPDATEëŠ” ê±´ë„ˆë›°ê¸°
                    continue;
                }
                
                // "update" í‚¤ì›Œë“œ ìì²´ëŠ” ì œì™¸
                if (alias.toUpperCase() === 'UPDATE') {
                    continue;
                }
                
                // UPDATE ë¸”ë¡ì˜ ëì„ ì°¾ê¸° (ë‹¤ìŒ ë¬¸ì¥ ì¢…ë£Œê¹Œì§€)
                var blockEnd = sqlText.indexOf(';', updateStart);
                if (blockEnd === -1) {
                    blockEnd = sqlText.length;
                }
                var updateBlock = sqlText.substring(updateStart, blockEnd);
                
                // SET ë‹¤ìŒì— ë‚˜ì˜¤ëŠ” FROM ì ˆ ì°¾ê¸° (ê´„í˜¸ ë°–ì˜ FROMë§Œ)
                // UPDATE ë¸”ë¡ì—ì„œ ëª¨ë“  FROM ìœ„ì¹˜ ì°¾ê¸°
                var fromMatches = [];
                var fromRegex = /FROM\s+([#]?[A-Za-z_][A-Za-z0-9_]*)/gi;
                var tempMatch;
                
                while ((tempMatch = fromRegex.exec(updateBlock)) !== null) {
                    var fromPos = tempMatch.index;
                    var tableName = tempMatch[1].trim();
                    
                    // SETê³¼ FROM ì‚¬ì´ì˜ í…ìŠ¤íŠ¸
                    var setPos = updateBlock.indexOf('SET');
                    if (setPos < fromPos) {
                        var setToFrom = updateBlock.substring(setPos, fromPos);
                        // ê´„í˜¸ ê°œìˆ˜ í™•ì¸
                        var openParens = (setToFrom.match(/\(/g) || []).length;
                        var closeParens = (setToFrom.match(/\)/g) || []).length;
                        
                        // ê´„í˜¸ê°€ ëª¨ë‘ ë‹«í˜€ìˆìœ¼ë©´ UPDATEì˜ FROM ì ˆ (ê´„í˜¸ ë°–)
                        if (openParens === closeParens) {
                            fromMatches.push({
                                pos: fromPos,
                                name: tableName
                            });
                        }
                    }
                }
                
                // ê°€ì¥ ë§ˆì§€ë§‰ FROMì´ UPDATEì˜ FROM ì ˆì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
                if (fromMatches.length > 0) {
                    var lastFrom = fromMatches[fromMatches.length - 1];
                    var tableName = lastFrom.name;
                    if (tableName && !isKeyword(tableName) && !isCTENameInFile(tableName, fileCTENames)) {
                        allTables.push({
                            type: 'update',
                            name: tableName,
                            fileName: fileName
                        });
                    }
                }
            }
        }
        
        function extractDeleteTables(sqlText, sqlUpper, fileName, fileCTENames) {
            // DELETE FROM í…Œì´ë¸”ëª… íŒ¨í„´ (OUTPUT ì œì™¸)
            var deletePattern = /DELETE\s+(?:FROM\s+)?([#]?[A-Za-z_][A-Za-z0-9_]*)/gi;
            var match;
            
            while ((match = deletePattern.exec(sqlText)) !== null) {
                var tableName = match[1].trim();
                // OUTPUT í‚¤ì›Œë“œ ì œì™¸
                if (tableName && !isKeyword(tableName) && tableName.toUpperCase() !== 'OUTPUT' && !isCTENameInFile(tableName, fileCTENames)) {
                    allTables.push({
                        type: 'delete',
                        name: tableName,
                        fileName: fileName
                    });
                }
            }
            
            // MERGE ë¬¸ ë‚´ë¶€ì˜ DELETE ì°¾ê¸°
            // MERGE í…Œì´ë¸”ëª… ... WHEN NOT MATCHED BY SOURCE ... THEN DELETE
            var mergeRegex = /MERGE\s+(?:INTO\s+)?((?:\[?[A-Za-z_][A-Za-z0-9_]*\]?\.)?\[?#?[A-Za-z_][A-Za-z0-9_]*\]?)/gi;
            var mergeMatch;
            
            while ((mergeMatch = mergeRegex.exec(sqlText)) !== null) {
                var mergeStart = mergeMatch.index;
                var fullTableRef = mergeMatch[1].trim();
                // ìŠ¤í‚¤ë§ˆëª… ì œê±°í•˜ê³  í…Œì´ë¸”ëª…ë§Œ ì¶”ì¶œ
                var tableName = extractTableNameFromRef(fullTableRef);
                
                // MERGE ë¸”ë¡ì˜ ëì„ ì°¾ê¸°
                var blockEnd = sqlText.indexOf(';', mergeStart);
                if (blockEnd === -1) {
                    blockEnd = sqlText.length;
                }
                var mergeBlock = sqlText.substring(mergeStart, blockEnd);
                
                // WHEN NOT MATCHED BY SOURCE ... THEN DELETE íŒ¨í„´ ì°¾ê¸°
                var deleteInMergePattern = /WHEN\s+NOT\s+MATCHED\s+BY\s+SOURCE[\s\S]*?THEN\s+DELETE/gi;
                if (deleteInMergePattern.test(mergeBlock)) {
                    if (tableName && !isKeyword(tableName) && !isCTENameInFile(tableName, fileCTENames)) {
                        allTables.push({
                            type: 'delete',
                            name: tableName,
                            fileName: fileName
                        });
                    }
                }
            }
        }
        
        function extractMergeTables(sqlText, sqlUpper, fileName, fileCTENames) {
            // MERGE í…Œì´ë¸”ëª… íŒ¨í„´ (INTO í‚¤ì›Œë“œ ì§€ì›, ìŠ¤í‚¤ë§ˆëª… í¬í•¨ ì§€ì›)
            // MERGE INTO schema.table ë˜ëŠ” MERGE schema.table ë˜ëŠ” MERGE table
            var mergePattern = /MERGE\s+(?:INTO\s+)?((?:\[?[A-Za-z_][A-Za-z0-9_]*\]?\.)?\[?#?[A-Za-z_][A-Za-z0-9_]*\]?)/gi;
            var match;
            
            while ((match = mergePattern.exec(sqlText)) !== null) {
                var mergeStart = match.index;
                var fullTableRef = match[1].trim();
                // ìŠ¤í‚¤ë§ˆëª… ì œê±°í•˜ê³  í…Œì´ë¸”ëª…ë§Œ ì¶”ì¶œ
                var tableName = extractTableNameFromRef(fullTableRef);
                
                if (tableName && !isKeyword(tableName) && !isCTENameInFile(tableName, fileCTENames)) {
                    allTables.push({
                        type: 'merge',
                        name: tableName,
                        fileName: fileName
                    });
                }
                
                // MERGE ë¸”ë¡ì˜ ëì„ ì°¾ê¸°
                var blockEnd = sqlText.indexOf(';', mergeStart);
                if (blockEnd === -1) {
                    blockEnd = sqlText.length;
                }
                var mergeBlock = sqlText.substring(mergeStart, blockEnd);
                
                // USING ì ˆ ë‚´ë¶€ì˜ ì„œë¸Œì¿¼ë¦¬ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
                // USING (SELECT ... FROM table) íŒ¨í„´
                var usingPattern = /USING\s*\(/gi;
                var usingMatch;
                while ((usingMatch = usingPattern.exec(mergeBlock)) !== null) {
                    var usingStart = usingMatch.index + usingMatch[0].length;
                    // USING ì ˆì˜ ê´„í˜¸ ë§¤ì¹­
                    var parenCount = 1;
                    var usingContent = '';
                    for (var i = usingStart; i < mergeBlock.length; i++) {
                        if (mergeBlock[i] === '(') {
                            parenCount++;
                        } else if (mergeBlock[i] === ')') {
                            parenCount--;
                            if (parenCount === 0) {
                                usingContent = mergeBlock.substring(usingStart, i);
                                break;
                            }
                        }
                    }
                    
                    // USING ì ˆ ë‚´ë¶€ì˜ ì„œë¸Œì¿¼ë¦¬ì—ì„œ í…Œì´ë¸” ì¶”ì¶œ
                    if (usingContent) {
                        extractTablesFromSubquery(usingContent, fileName, fileCTENames);
                    }
                }
            }
        }
        
        function extractProcedureCalls(sqlText, sqlUpper, fileName, fileCTENames) {
            // EXEC, EXECUTE, CALL íŒ¨í„´ ì°¾ê¸°
            // EXEC ProcedureName
            // EXEC dbo.ProcedureName
            // EXEC [dbo].[ProcedureName]
            // EXECUTE ProcedureName
            // CALL ProcedureName
            // CALL schema.ProcedureName
            var execPattern = /(?:EXEC|EXECUTE|CALL)\s+(?:\[?([A-Za-z_][A-Za-z0-9_]*)\]?\.)?\[?([A-Za-z_][A-Za-z0-9_]*)\]?/gi;
            var match;
            var seen = {};
            
            while ((match = execPattern.exec(sqlText)) !== null) {
                var procName = '';
                // match[2]ëŠ” í”„ë¡œì‹œì €ëª…, match[1]ì€ ìŠ¤í‚¤ë§ˆëª…
                if (match[2]) {
                    procName = match[2].trim();
                } else if (match[1]) {
                    // ìŠ¤í‚¤ë§ˆë§Œ ìˆê³  í”„ë¡œì‹œì €ëª…ì´ ì—†ëŠ” ê²½ìš° (ë“œë¬¼ì§€ë§Œ)
                    procName = match[1].trim();
                }
                
                if (procName && !isKeyword(procName) && !isCTENameInFile(procName, fileCTENames)) {
                    var key = 'exec|' + procName.toUpperCase() + '|' + fileName;
                    if (!seen[key]) {
                        seen[key] = true;
                        allTables.push({
                            type: 'exec',
                            name: procName,
                            fileName: fileName
                        });
                    }
                }
            }
        }
        
        function isKeyword(word) {
            var keywords = ['AS', 'ON', 'WHERE', 'SET', 'VALUES', 'INTO', 'FROM', 'JOIN', 'INNER', 'LEFT', 'RIGHT', 'FULL', 'OUTER', 
                            'UPDATE', 'DELETE', 'INSERT', 'SELECT', 'MERGE', 'WHEN', 'THEN', 'MATCHED', 'USING', 'TARGET', 'SOURCE',
                            'AND', 'OR', 'NOT', 'IN', 'EXISTS', 'IS', 'NULL', 'BY', 'GROUP', 'ORDER', 'HAVING', 'UNION', 'ALL',
                            'CASE', 'ELSE', 'END', 'DUAL'];
            return keywords.indexOf(word.toUpperCase()) !== -1;
        }
        
        function isCTEName(word) {
            return cteNames.indexOf(word.toUpperCase()) !== -1;
        }
        
        function isCTENameInFile(word, fileCTENames) {
            return fileCTENames.indexOf(word.toUpperCase()) !== -1;
        }
        
        function removeDuplicates() {
            var seen = {};
            var unique = [];
            
            for (var i = 0; i < allTables.length; i++) {
                // íŒŒì¼ëª…ë„ í¬í•¨í•˜ì—¬ ì¤‘ë³µ ì²´í¬ (ê°™ì€ íŒŒì¼ì—ì„œ ê°™ì€ íƒ€ì…+í…Œì´ë¸”ì€ ì¤‘ë³µ ì œê±°)
                var key = allTables[i].type + '|' + allTables[i].name + '|' + allTables[i].fileName;
                if (!seen[key]) {
                    seen[key] = true;
                    unique.push(allTables[i]);
                }
            }
            
            allTables = unique;
        }
        
        function displayResults() {
            if (allTables.length === 0) {
                document.getElementById('resultSection').style.display = 'none';
                alert('í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            // í†µê³„ ê³„ì‚°
            var stats = {
                select: 0,
                insert: 0,
                update: 0,
                delete: 0,
                merge: 0,
                exec: 0,
                total: allTables.length
            };
            
            for (var i = 0; i < allTables.length; i++) {
                var type = allTables[i].type;
                if (stats[type] !== undefined) {
                    stats[type]++;
                }
            }
            
            // í†µê³„ í‘œì‹œ
            var statsHtml = '<div class="stat-item">' +
                '<div class="number">' + stats.total + '</div>' +
                '<div class="label">ì „ì²´</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="number">' + stats.select + '</div>' +
                '<div class="label">SELECT</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="number">' + stats.insert + '</div>' +
                '<div class="label">INSERT</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="number">' + stats.update + '</div>' +
                '<div class="label">UPDATE</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="number">' + stats.delete + '</div>' +
                '<div class="label">DELETE</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="number">' + stats.merge + '</div>' +
                '<div class="label">MERGE</div>' +
                '</div>' +
                '<div class="stat-item">' +
                '<div class="number">' + stats.exec + '</div>' +
                '<div class="label">PROCEDURE</div>' +
                '</div>';
            
            document.getElementById('stats').innerHTML = statsHtml;
            
            // í…Œì´ë¸” ì •ë ¬ (íŒŒì¼ëª…ë³„, íƒ€ì…ë³„, ì´ë¦„ë³„)
            allTables.sort(function(a, b) {
                // íŒŒì¼ëª… ë¨¼ì € ì •ë ¬
                if (a.fileName !== b.fileName) {
                    return a.fileName.localeCompare(b.fileName);
                }
                // íƒ€ì…ë³„ ì •ë ¬
                if (a.type !== b.type) {
                    var order = {select: 1, insert: 2, update: 3, delete: 4, merge: 5, exec: 6};
                    return (order[a.type] || 99) - (order[b.type] || 99);
                }
                // ì´ë¦„ë³„ ì •ë ¬
                return a.name.localeCompare(b.name);
            });
            
            filteredTables = allTables;
            filterTable();
            
            document.getElementById('resultSection').style.display = 'block';
        }
        
        function filterTable() {
            var filterType = document.getElementById('typeFilter').value;
            
            if (filterType === 'all') {
                filteredTables = allTables;
            } else {
                filteredTables = [];
                for (var i = 0; i < allTables.length; i++) {
                    if (allTables[i].type === filterType) {
                        filteredTables.push(allTables[i]);
                    }
                }
            }
            
            renderTable();
        }
        
        function renderTable() {
            var container = document.getElementById('tableContainer');
            
            if (filteredTables.length === 0) {
                container.innerHTML = '<div class="no-results">ì„ íƒí•œ íƒ€ì…ì˜ í…Œì´ë¸”ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }
            
            var html = '<table><thead><tr>' +
                '<th style="width: 80px; text-align: center;">No</th>' +
                '<th style="width: 200px;">File Name</th>' +
                '<th style="width: 150px;">Type <input type="checkbox" id="checkType" style="margin-left: 5px;"></th>' +
                '<th>Table Name <input type="checkbox" id="checkTableName" style="margin-left: 5px;"></th>' +
                '</tr></thead><tbody>';
            
            for (var i = 0; i < filteredTables.length; i++) {
                var item = filteredTables[i];
                var typeClass = 'type-' + item.type;
                var typeDisplay = item.type.toUpperCase();
                // EXEC íƒ€ì…ì„ PROCEDUREë¡œ í‘œì‹œ
                if (item.type === 'exec') {
                    typeDisplay = 'PROCEDURE';
                }
                html += '<tr>' +
                    '<td style="text-align: center; color: #666;">' + (i + 1) + '</td>' +
                    '<td><span style="font-family: monospace; font-size: 13px;">' + escapeHtml(item.fileName || 'ì§ì ‘ ì…ë ¥') + '</span></td>' +
                    '<td><span class="type-badge ' + typeClass + '">' + typeDisplay + '</span></td>' +
                    '<td><span class="table-name">' + escapeHtml(item.name) + '</span></td>' +
                    '</tr>';
            }
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        
        function copySelectedColumns() {
            var checkType = document.getElementById('checkType');
            var checkTableName = document.getElementById('checkTableName');
            
            if (!checkType || !checkTableName) {
                alert('ê·¸ë¦¬ë“œë¥¼ ë¨¼ì € ìƒì„±í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            var typeChecked = checkType.checked;
            var nameChecked = checkTableName.checked;
            
            if (!typeChecked && !nameChecked) {
                alert('ë³µì‚¬í•  ì»¬ëŸ¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            var copyText = '';
            
            // í—¤ë” ìƒì„±
            var includeFileName = filteredTables.length > 0 && filteredTables[0].fileName;
            if (includeFileName) {
                if (typeChecked && nameChecked) {
                    copyText = 'file name  |  type   |  name\n';
                } else if (typeChecked) {
                    copyText = 'file name  |  type\n';
                } else if (nameChecked) {
                    copyText = 'file name  |  name\n';
                }
            } else {
                if (typeChecked && nameChecked) {
                    copyText = 'type   |  name\n';
                } else if (typeChecked) {
                    copyText = 'type\n';
                } else if (nameChecked) {
                    copyText = 'name\n';
                }
            }
            
            // ë°ì´í„° ë³µì‚¬
            for (var i = 0; i < filteredTables.length; i++) {
                var item = filteredTables[i];
                if (includeFileName) {
                    if (typeChecked && nameChecked) {
                        copyText += (item.fileName || 'ì§ì ‘ ì…ë ¥') + '  |  ' + item.type + '  |  ' + item.name + '\n';
                    } else if (typeChecked) {
                        copyText += (item.fileName || 'ì§ì ‘ ì…ë ¥') + '  |  ' + item.type + '\n';
                    } else if (nameChecked) {
                        copyText += (item.fileName || 'ì§ì ‘ ì…ë ¥') + '  |  ' + item.name + '\n';
                    }
                } else {
                    if (typeChecked && nameChecked) {
                        copyText += item.type + '  |  ' + item.name + '\n';
                    } else if (typeChecked) {
                        copyText += item.type + '\n';
                    } else if (nameChecked) {
                        copyText += item.name + '\n';
                    }
                }
            }
            
            // í´ë¦½ë³´ë“œì— ë³µì‚¬
            var textarea = document.createElement('textarea');
            textarea.value = copyText;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                document.execCommand('copy');
                alert('ì„ íƒí•œ ì»¬ëŸ¼ ë°ì´í„°ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } catch (err) {
                alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.\n\n' + copyText);
            }
            
            document.body.removeChild(textarea);
        }
        
        function escapeHtml(text) {
            var map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }
        
        function clearAll() {
            document.getElementById('sqlInput').value = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileList').innerHTML = '';
            document.getElementById('resultSection').style.display = 'none';
            allTables = [];
            filteredTables = [];
            uploadedFiles = [];
        }
    </script>
</body>
</html>

