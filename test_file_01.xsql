<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.TestMapper01">
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 복잡한 SELECT 쿼리 1 -->
    <select id="selectOrderDetails_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            c.CustomerName,
            o.OrderDate,
            o.SalesPersonId,
            e.EmployeeName,
            d.DepartmentName,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        GROUP BY o.OrderId, o.CustomerId, c.CustomerName, o.OrderDate, 
                 o.SalesPersonId, e.EmployeeName, d.DepartmentName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minAmount}
        ORDER BY OrderTotal DESC
    </select>
    
    <!-- CTE를 사용한 복잡한 SELECT 쿼리 -->
    <select id="selectCustomerAnalysis_001" resultType="map">
        WITH CustomerOrders AS (
            SELECT 
                c.CustomerId,
                c.CustomerName,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY c.CustomerId, c.CustomerName
        ),
        ProductSales AS (
            SELECT 
                p.ProductId,
                p.ProductName,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= #{startDate}
            GROUP BY p.ProductId, p.ProductName
        )
        SELECT 
            co.CustomerId,
            co.CustomerName,
            co.OrderCount,
            co.TotalSpent,
            COUNT(DISTINCT ps.ProductId) AS ProductCount
        FROM CustomerOrders co
        INNER JOIN Orders o ON co.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN ProductSales ps ON od.ProductId = ps.ProductId
        GROUP BY co.CustomerId, co.CustomerName, co.OrderCount, co.TotalSpent
        ORDER BY co.TotalSpent DESC
    </select>
    
    <!-- 서브쿼리가 많은 SELECT -->
    <select id="selectComplexOrderData_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            (SELECT CustomerName FROM Customers WHERE CustomerId = o.CustomerId) AS CustomerName,
            (SELECT COUNT(*) FROM OrderDetails WHERE OrderId = o.OrderId) AS DetailCount,
            (SELECT SUM(Quantity * UnitPrice * (1 - Discount)) 
             FROM OrderDetails 
             WHERE OrderId = o.OrderId) AS OrderTotal,
            (SELECT EmployeeName 
             FROM Employees 
             WHERE EmployeeId = o.SalesPersonId) AS SalesPersonName,
            (SELECT DepartmentName 
             FROM Departments d
             INNER JOIN Employees e ON d.DepartmentId = e.DepartmentId
             WHERE e.EmployeeId = o.SalesPersonId) AS DepartmentName
        FROM Orders o
        WHERE o.OrderDate >= #{startDate}
          AND EXISTS (
              SELECT 1
              FROM OrderDetails od
              WHERE od.OrderId = o.OrderId
                AND od.Quantity * od.UnitPrice > #{minLineTotal}
          )
          AND NOT EXISTS (
              SELECT 1
              FROM OrderCancellations oc
              WHERE oc.OrderId = o.OrderId
          )
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- INSERT 문 -->
    <insert id="insertOrderArchive_001" parameterType="map">
        INSERT INTO OrderArchive (OrderId, CustomerId, OrderDate, OrderTotal, ArchivedDate)
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal,
            GETDATE() AS ArchivedDate
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate &lt; DATEADD(YEAR, -2, GETDATE())
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate
    </insert>
    
    <!-- UPDATE 문 -->
    <update id="updateProductInventory_001" parameterType="map">
        UPDATE Products
        SET UnitsInStock = UnitsInStock + (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        ),
        UnitsOnOrder = UnitsOnOrder - (
            SELECT ISNULL(SUM(po.Quantity), 0)
            FROM PurchaseOrders po
            WHERE po.ProductId = Products.ProductId
              AND po.ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND po.Status = 'Received'
        )
        WHERE ProductId IN (
            SELECT DISTINCT ProductId
            FROM PurchaseOrders
            WHERE ReceivedDate >= DATEADD(DAY, -30, GETDATE())
              AND Status = 'Received'
        )
    </update>
    
    <!-- DELETE 문 -->
    <delete id="deleteOldOrderDetails_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT o.OrderId
            FROM Orders o
            WHERE o.OrderDate &lt; DATEADD(YEAR, -5, GETDATE())
              AND o.OrderId NOT IN (
                  SELECT DISTINCT OrderId
                  FROM OrderArchive
              )
        )
    </delete>
    
    <!-- MERGE 문 -->
    <update id="mergeCustomerOrderSummary_001" parameterType="map">
        MERGE INTO CustomerOrderSummary AS target
        USING (
            SELECT 
                c.CustomerId,
                d.DepartmentId,
                COUNT(DISTINCT o.OrderId) AS OrderCount,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount,
                AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgAmount,
                MAX(o.OrderDate) AS LastProcessDate,
                MIN(o.OrderDate) AS FirstProcessDate,
                COUNT(DISTINCT od.ProductId) AS ProductCount
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
            INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
            WHERE o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
            GROUP BY c.CustomerId, d.DepartmentId
        ) AS source
        ON target.CustomerId = source.CustomerId
           AND target.DepartmentId = source.DepartmentId
        WHEN MATCHED THEN
            UPDATE SET 
                target.OrderCount = source.OrderCount,
                target.TotalAmount = source.TotalAmount,
                target.AvgAmount = source.AvgAmount,
                target.LastProcessDate = source.LastProcessDate,
                target.FirstProcessDate = source.FirstProcessDate,
                target.ProductCount = source.ProductCount,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, DepartmentId, OrderCount, TotalAmount, AvgAmount, 
                    LastProcessDate, FirstProcessDate, ProductCount, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.DepartmentId, source.OrderCount, 
                    source.TotalAmount, source.AvgAmount, source.LastProcessDate, 
                    source.FirstProcessDate, source.ProductCount, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 문 -->
    <select id="executeStoredProcedure_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 반복 패턴 시작 - 다양한 SELECT 쿼리들 -->
    <select id="selectProductSales_001" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_001" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_001" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <!-- INSERT 패턴들 -->
    <insert id="insertProductSalesHistory_001" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_001" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <!-- UPDATE 패턴들 -->
    <update id="updateCustomerCreditLimit_001" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_001" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <!-- DELETE 패턴들 -->
    <delete id="deleteTempData_001" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_001" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <!-- MERGE 패턴들 -->
    <update id="mergeCustomerLifetimeValue_001" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_001" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <!-- EXEC 패턴들 -->
    <select id="execUpdateStatistics_001" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_001" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_001" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <!-- 복잡한 JOIN이 많은 쿼리들 -->
    <select id="selectComplexJoinQuery_001" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <!-- 동적 SQL 쿼리 -->
    <select id="selectDynamicOrders_001" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <!-- 재귀 CTE 쿼리 -->
    <select id="selectDepartmentHierarchy_001" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <!-- UNION 쿼리 -->
    <select id="selectCombinedSalesData_001" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <!-- CASE WHEN이 많은 쿼리 -->
    <select id="selectCustomerSegmentation_001" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 반복 패턴 계속 (002~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_002" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_002" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_002" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_002" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_002" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_002" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_002" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_002" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_002" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_002" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_002" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_002" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_002" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_002" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_003" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_002" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_002" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_002" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_002" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복... (003~150까지 반복하여 약 2000줄까지) -->
    <select id="selectProductSales_003" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_003" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_003" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_003" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_003" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_003" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_003" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_003" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_003" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_003" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_003" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_003" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_003" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_003" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_005" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_006" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_003" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_003" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_003" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_003" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 계속 반복하여 약 2000줄까지 생성 (004~150) -->
    <select id="selectProductSales_004" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_004" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_004" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_004" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_004" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_004" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_004" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_004" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_004" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_004" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_004" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_004" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_004" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_004" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_007" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_008" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_004" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_004" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_004" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_004" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
    <!-- 추가 반복 패턴 (005~010) -->
    <select id="selectProductSales_005" resultType="map">
        SELECT 
            p.ProductId,
            p.ProductName,
            cat.CategoryName,
            s.SupplierName,
            p.UnitPrice,
            COUNT(DISTINCT od.OrderId) AS OrderCount,
            SUM(od.Quantity) AS TotalQuantitySold,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue
        FROM Products p
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        LEFT JOIN OrderDetails od ON p.ProductId = od.ProductId
        LEFT JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= #{startDate}
           OR o.OrderDate IS NULL
        GROUP BY p.ProductId, p.ProductName, cat.CategoryName, s.SupplierName, p.UnitPrice
        ORDER BY TotalRevenue DESC
    </select>
    
    <select id="selectEmployeePerformance_005" resultType="map">
        SELECT 
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentName,
            COUNT(DISTINCT o.OrderId) AS TotalOrders,
            COUNT(DISTINCT o.CustomerId) AS CustomerCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        LEFT JOIN Orders o ON e.EmployeeId = o.SalesPersonId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY e.EmployeeId, e.EmployeeName, d.DepartmentName
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectRegionalSales_005" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            COUNT(DISTINCT c.CustomerId) AS CustomerCount,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue
        FROM Regions r
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName
        ORDER BY TotalSales DESC
    </select>
    
    <insert id="insertProductSalesHistory_005" parameterType="map">
        INSERT INTO ProductSalesHistory (ProductId, CategoryId, SupplierId, SalesYear, SalesMonth, 
                                        TotalQuantity, TotalRevenue, OrderCount)
        SELECT 
            p.ProductId,
            p.CategoryId,
            p.SupplierId,
            YEAR(o.OrderDate) AS SalesYear,
            MONTH(o.OrderDate) AS SalesMonth,
            SUM(od.Quantity) AS TotalQuantity,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
            COUNT(DISTINCT od.OrderId) AS OrderCount
        FROM Products p
        INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
        INNER JOIN Orders o ON od.OrderId = o.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        GROUP BY p.ProductId, p.CategoryId, p.SupplierId, YEAR(o.OrderDate), MONTH(o.OrderDate)
    </insert>
    
    <insert id="insertCustomerMetrics_005" parameterType="map">
        INSERT INTO CustomerMetrics (CustomerId, OrderCount, TotalSpent, AvgOrderAmount, 
                                     LastPurchaseDate, FirstPurchaseDate)
        SELECT 
            c.CustomerId,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderAmount,
            MAX(o.OrderDate) AS LastPurchaseDate,
            MIN(o.OrderDate) AS FirstPurchaseDate
        FROM Customers c
        INNER JOIN Orders o ON c.CustomerId = o.CustomerId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY c.CustomerId
    </insert>
    
    <update id="updateCustomerCreditLimit_005" parameterType="map">
        UPDATE Customers
        SET CreditLimit = (
            SELECT CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 50000
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 25000
                ELSE 10000
            END
            FROM Orders o
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            WHERE o.CustomerId = Customers.CustomerId
              AND o.OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
        WHERE CustomerId IN (
            SELECT DISTINCT CustomerId
            FROM Orders
            WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())
        )
    </update>
    
    <update id="updateProductPrices_005" parameterType="map">
        UPDATE Products
        SET UnitPrice = UnitPrice * (1 + #{priceIncreasePercent} / 100.0)
        WHERE CategoryId IN (
            SELECT CategoryId
            FROM Categories
            WHERE CategoryName IN
            <foreach collection="categoryNames" item="name" open="(" separator="," close=")">
                #{name}
            </foreach>
        )
    </update>
    
    <delete id="deleteTempData_005" parameterType="map">
        DELETE FROM TempProcessingQueue
        WHERE ProcessedDate &lt; DATEADD(DAY, -7, GETDATE())
          AND Status = 'Completed'
          AND NOT EXISTS (
              SELECT 1
              FROM ErrorLog el
              WHERE el.ProcessId = TempProcessingQueue.ProcessId
          )
    </delete>
    
    <delete id="deleteOldRecords_005" parameterType="map">
        DELETE FROM OrderDetails
        WHERE OrderId IN (
            SELECT OrderId
            FROM Orders
            WHERE OrderDate &lt; DATEADD(YEAR, -#{yearsToKeep}, GETDATE())
        )
    </delete>
    
    <update id="mergeCustomerLifetimeValue_005" parameterType="map">
        MERGE INTO CustomerLifetimeValue AS target
        USING (
            SELECT 
                c.CustomerId,
                COUNT(DISTINCT o.OrderId) AS TotalOrders,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LifetimeValue,
                MIN(o.OrderDate) AS FirstOrderDate,
                MAX(o.OrderDate) AS LastOrderDate,
                DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) AS CustomerLifespanDays
            FROM Customers c
            INNER JOIN Orders o ON c.CustomerId = o.CustomerId
            INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
            GROUP BY c.CustomerId
        ) AS source
        ON target.CustomerId = source.CustomerId
        WHEN MATCHED THEN
            UPDATE SET 
                target.TotalOrders = source.TotalOrders,
                target.LifetimeValue = source.LifetimeValue,
                target.FirstOrderDate = source.FirstOrderDate,
                target.LastOrderDate = source.LastOrderDate,
                target.CustomerLifespanDays = source.CustomerLifespanDays,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (CustomerId, TotalOrders, LifetimeValue, FirstOrderDate, 
                    LastOrderDate, CustomerLifespanDays, CreatedDate, UpdatedDate)
            VALUES (source.CustomerId, source.TotalOrders, source.LifetimeValue, 
                    source.FirstOrderDate, source.LastOrderDate, source.CustomerLifespanDays, 
                    GETDATE(), GETDATE())
    </update>
    
    <update id="mergeProductPerformance_005" parameterType="map">
        MERGE INTO ProductPerformanceMetrics AS target
        USING (
            SELECT 
                p.ProductId,
                p.CategoryId,
                COUNT(DISTINCT od.OrderId) AS OrderCount,
                SUM(od.Quantity) AS TotalQuantitySold,
                SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalRevenue,
                AVG(od.UnitPrice * (1 - od.Discount)) AS AvgSellingPrice,
                MAX(o.OrderDate) AS LastSaleDate
            FROM Products p
            INNER JOIN OrderDetails od ON p.ProductId = od.ProductId
            INNER JOIN Orders o ON od.OrderId = o.OrderId
            WHERE o.OrderDate >= DATEADD(MONTH, -12, GETDATE())
            GROUP BY p.ProductId, p.CategoryId
        ) AS source
        ON target.ProductId = source.ProductId
        WHEN MATCHED THEN
            UPDATE SET 
                target.CategoryId = source.CategoryId,
                target.OrderCount = source.OrderCount,
                target.TotalQuantitySold = source.TotalQuantitySold,
                target.TotalRevenue = source.TotalRevenue,
                target.AvgSellingPrice = source.AvgSellingPrice,
                target.LastSaleDate = source.LastSaleDate,
                target.UpdatedDate = GETDATE()
        WHEN NOT MATCHED THEN
            INSERT (ProductId, CategoryId, OrderCount, TotalQuantitySold, TotalRevenue, 
                    AvgSellingPrice, LastSaleDate, CreatedDate, UpdatedDate)
            VALUES (source.ProductId, source.CategoryId, source.OrderCount, 
                    source.TotalQuantitySold, source.TotalRevenue, source.AvgSellingPrice, 
                    source.LastSaleDate, GETDATE(), GETDATE())
    </update>
    
    <select id="execUpdateStatistics_005" statementType="CALLABLE" resultType="map">
        { CALL sp_UpdateCustomerStatistics(#{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="execCalculateBonus_005" statementType="CALLABLE" resultType="map">
        { CALL dbo.sp_CalculateEmployeeBonus(#{departmentId, mode=IN, jdbcType=INTEGER}) }
    </select>
    
    <select id="execProcessRegionalData_005" statementType="CALLABLE" resultType="map">
        { CALL [dbo].[sp_ProcessRegionalData](#{regionId, mode=IN, jdbcType=INTEGER}, 
                                               #{processDate, mode=IN, jdbcType=TIMESTAMP}) }
    </select>
    
    <select id="selectComplexJoinQuery_009" resultType="map">
        SELECT 
            o.OrderId,
            o.OrderDate,
            c.CustomerId,
            c.CustomerName,
            c.CustomerTypeId,
            ct.CustomerTypeName,
            e.EmployeeId,
            e.EmployeeName,
            d.DepartmentId,
            d.DepartmentName,
            p.ProductId,
            p.ProductName,
            cat.CategoryId,
            cat.CategoryName,
            s.SupplierId,
            s.SupplierName,
            od.Quantity,
            od.UnitPrice,
            od.Discount,
            (od.Quantity * od.UnitPrice * (1 - od.Discount)) AS LineTotal
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerId = c.CustomerId
        INNER JOIN CustomerTypes ct ON c.CustomerTypeId = ct.CustomerTypeId
        INNER JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        INNER JOIN Departments d ON e.DepartmentId = d.DepartmentId
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        INNER JOIN Products p ON od.ProductId = p.ProductId
        INNER JOIN Categories cat ON p.CategoryId = cat.CategoryId
        INNER JOIN Suppliers s ON p.SupplierId = s.SupplierId
        WHERE o.OrderDate >= #{startDate}
          AND o.OrderDate &lt;= #{endDate}
        ORDER BY o.OrderDate DESC, o.OrderId, od.OrderDetailId
    </select>
    
    <select id="selectComplexJoinQuery_010" resultType="map">
        SELECT 
            r.RegionId,
            r.RegionName,
            co.CountryId,
            co.CountryName,
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSales,
            AVG(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS AvgOrderValue,
            COUNT(DISTINCT e.EmployeeId) AS EmployeeCount,
            COUNT(DISTINCT p.ProductId) AS ProductCount
        FROM Regions r
        INNER JOIN Countries co ON r.CountryId = co.CountryId
        LEFT JOIN Customers c ON r.RegionId = c.RegionId
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        LEFT JOIN Employees e ON o.SalesPersonId = e.EmployeeId
        LEFT JOIN Products p ON od.ProductId = p.ProductId
        WHERE o.OrderDate >= #{startDate}
        GROUP BY r.RegionId, r.RegionName, co.CountryId, co.CountryName, 
                 c.CustomerId, c.CustomerName
        HAVING SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > #{minSales}
        ORDER BY TotalSales DESC
    </select>
    
    <select id="selectDynamicOrders_005" resultType="map">
        SELECT 
            o.OrderId,
            o.CustomerId,
            o.OrderDate,
            o.SalesPersonId,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS OrderTotal
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE 1=1
        <if test="customerId != null">
            AND o.CustomerId = #{customerId}
        </if>
        <if test="startDate != null">
            AND o.OrderDate >= #{startDate}
        </if>
        <if test="endDate != null">
            AND o.OrderDate &lt;= #{endDate}
        </if>
        <if test="employeeId != null">
            AND o.SalesPersonId = #{employeeId}
        </if>
        <if test="minAmount != null">
            AND EXISTS (
                SELECT 1
                FROM OrderDetails od2
                WHERE od2.OrderId = o.OrderId
                GROUP BY od2.OrderId
                HAVING SUM(od2.Quantity * od2.UnitPrice * (1 - od2.Discount)) >= #{minAmount}
            )
        </if>
        GROUP BY o.OrderId, o.CustomerId, o.OrderDate, o.SalesPersonId
        ORDER BY o.OrderDate DESC
    </select>
    
    <select id="selectDepartmentHierarchy_005" resultType="map">
        WITH DepartmentHierarchy AS (
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                0 AS Level,
                CAST(d.DepartmentName AS VARCHAR(MAX)) AS Path
            FROM Departments d
            WHERE d.ParentDepartmentId IS NULL
            
            UNION ALL
            
            SELECT 
                d.DepartmentId,
                d.DepartmentName,
                d.ParentDepartmentId,
                d.ManagerId,
                dh.Level + 1,
                CAST(dh.Path + ' > ' + d.DepartmentName AS VARCHAR(MAX))
            FROM Departments d
            INNER JOIN DepartmentHierarchy dh ON d.ParentDepartmentId = dh.DepartmentId
        )
        SELECT 
            dh.DepartmentId,
            dh.DepartmentName,
            dh.ParentDepartmentId,
            dh.ManagerId,
            e.EmployeeName AS ManagerName,
            dh.Level,
            dh.Path,
            COUNT(DISTINCT e2.EmployeeId) AS EmployeeCount
        FROM DepartmentHierarchy dh
        LEFT JOIN Employees e ON dh.ManagerId = e.EmployeeId
        LEFT JOIN Employees e2 ON dh.DepartmentId = e2.DepartmentId
        GROUP BY dh.DepartmentId, dh.DepartmentName, dh.ParentDepartmentId, 
                 dh.ManagerId, e.EmployeeName, dh.Level, dh.Path
        ORDER BY dh.Level, dh.Path
    </select>
    
    <select id="selectCombinedSalesData_005" resultType="map">
        SELECT 
            'Online' AS SalesChannel,
            o.OrderId,
            o.OrderDate,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalAmount
        FROM Orders o
        INNER JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderChannel = 'Online'
          AND o.OrderDate >= #{startDate}
        GROUP BY o.OrderId, o.OrderDate
        
        UNION ALL
        
        SELECT 
            'Store' AS SalesChannel,
            s.SaleId AS OrderId,
            s.SaleDate AS OrderDate,
            SUM(sd.Quantity * sd.UnitPrice * (1 - sd.Discount)) AS TotalAmount
        FROM StoreSales s
        INNER JOIN StoreSaleDetails sd ON s.SaleId = sd.SaleId
        WHERE s.SaleDate >= #{startDate}
        GROUP BY s.SaleId, s.SaleDate
        
        ORDER BY OrderDate DESC
    </select>
    
    <select id="selectCustomerSegmentation_005" resultType="map">
        SELECT 
            c.CustomerId,
            c.CustomerName,
            COUNT(DISTINCT o.OrderId) AS OrderCount,
            SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS TotalSpent,
            CASE 
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 100000
                THEN 'Platinum'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 50000
                THEN 'Gold'
                WHEN SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) > 10000
                THEN 'Silver'
                ELSE 'Bronze'
            END AS CustomerSegment,
            CASE 
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 30
                THEN 'Active'
                WHEN DATEDIFF(DAY, MAX(o.OrderDate), GETDATE()) &lt;= 90
                THEN 'Inactive'
                ELSE 'Dormant'
            END AS CustomerStatus
        FROM Customers c
        LEFT JOIN Orders o ON c.CustomerId = o.CustomerId
        LEFT JOIN OrderDetails od ON o.OrderId = od.OrderId
        WHERE o.OrderDate >= DATEADD(YEAR, -2, GETDATE())
           OR o.OrderDate IS NULL
        GROUP BY c.CustomerId, c.CustomerName
        ORDER BY TotalSpent DESC
    </select>
    
</mapper>

